#!/usr/bin/env bash
TARGET=$1
TIMEOUT=${2:-2}
RECHECKS=${3:-5}
RECHECK_INTERVAL=${4:-5}
HOST="$(echo "${TARGET}" | cut -d/ -f3 | sed 's/:[0-9]*$//')"
PORT="$(echo "${TARGET}" | cut -d/ -f3 | awk -F: '(NF==2){print $2} (NF==1){print 1965}')"
REMOTE_PATH="/$(echo ${TARGET} | cut -d/ -f4-)"
RUNDIR="${RUNDIR:-${HOME}/.local/share/gemini-healthchecker/${HOST}:${PORT}}"

set -euo pipefail

_usage()        { echo "Usage: $(basename "$0") TARGET [TIMEOUT] [RECHECKS] [RECHECK_INTERVAL]"; }
_is_up()        { [[ $(tail -n1 "${RUNDIR}/state") -eq 20 ]]; }
_is_down()      { ! _is_up; }
_was_up()       { [[ $(tail -n1 "${RUNDIR}/last_state") -eq 20 ]]; }
_was_down()     { ! _was_up; }
_last_success() { eval $(stat -s "${RUNDIR}/last_success"); echo ${st_mtime}; }
_print_date()   { date -u -r $1 +%Y-%m-%dT%H:%M:%S%z; }
_test_target()  { _gemini_status_code >> "${RUNDIR}/state"; }
_check_dep()    { command -v "$1" &>/dev/null || _error "$1: command not found"; }
_error()        { echo -e "$@" >&2 && exit 1; }
_locked()       { [[ -f "${RUNDIR}/lock" ]]; }
_lock()         { touch "${RUNDIR}/lock"; }
_unlock()       { rm -f "${RUNDIR}/lock"; }

_gemini_status_code() {
  _check_dep "gemget"
  gemget gemini://${HOST}${REMOTE_PATH} -t ${TIMEOUT} --header -o /dev/null 2>/dev/null \
    | grep ^Header \
    | awk '{ print $2 }' \
    || echo 0
}

[[ $# -eq 0 ]] || [[ $# -gt 4 ]] && _usage && exit 1
[[ "$*" =~ --help ]]             && _usage && exit 0
[[ ${TARGET} =~ ^gemini:// ]]    || _error "TARGET must have a gemini protocol"

mkdir -p "${RUNDIR}"
if _locked; then
  _error "Lockfile exists for ${TARGET}\n\nTimeout is too long, or checks are too frequent. Adjust to prevent overlapping checks."
else
  _lock
fi

trap '_unlock' 1 2 3 6 9 15

if [[ -f "${RUNDIR}/state" ]]; then
  mv "${RUNDIR}/state" "${RUNDIR}/last_state"
else
  echo 20 > "${RUNDIR}/last_state"  # assume it's ok
fi
touch "${RUNDIR}/state"

for ((i=0;i<RECHECKS;i++)); do
  _test_target
  _is_up && touch "${RUNDIR}/last_success" && break
  sleep "${RECHECK_INTERVAL}"
done

if _is_up && _was_down; then
  echo "${TARGET} has recovered since failing at $(_print_date "@$(_last_success)")"
elif _is_down && _was_up; then
  echo "${TARGET} has entered an alarm state at $(_print_date)"
fi

_unlock
